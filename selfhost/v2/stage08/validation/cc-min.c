#include <stdio.h>
#include <stdint.h>

#define MAX_SRC 8192

static char g_src[MAX_SRC];
static uint32_t g_pos;

static int read_file(const char *path, char *buf, uint32_t max_len, uint32_t *out_len) {
    FILE *f;
    uint32_t n;
    int ch;

    f = fopen(path, "rb");
    if (!f) return 0;
    n = 0;
    for (;;) {
        ch = fgetc(f);
        if (ch == EOF) break;
        if (n + 1 >= max_len) {
            fclose(f);
            return 0;
        }
        buf[n] = (char)ch;
        n = n + 1;
    }
    fclose(f);
    buf[n] = 0;
    *out_len = n;
    return 1;
}

static int is_space_char(char c) {
    return c == ' ' || c == '\t' || c == '\n' || c == '\r';
}

static int is_alpha_char(char c) {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_';
}

static int is_digit_char(char c) {
    return c >= '0' && c <= '9';
}

static void skip_space(void) {
    while (is_space_char(g_src[g_pos])) g_pos = g_pos + 1;
}

static int consume_char(char ch) {
    skip_space();
    if (g_src[g_pos] != ch) return 0;
    g_pos = g_pos + 1;
    return 1;
}

static int consume_kw(const char *kw) {
    uint32_t i = 0;
    skip_space();
    while (kw[i] != 0) {
        if (g_src[g_pos + i] != kw[i]) return 0;
        i = i + 1;
    }
    if (is_alpha_char(g_src[g_pos + i]) || is_digit_char(g_src[g_pos + i])) return 0;
    g_pos = g_pos + i;
    return 1;
}

static int parse_int_lit(int *out_v) {
    int sign = 1;
    int v = 0;
    int any = 0;

    skip_space();
    if (g_src[g_pos] == '-') {
        sign = -1;
        g_pos = g_pos + 1;
    }
    while (is_digit_char(g_src[g_pos])) {
        any = 1;
        v = v * 10 + (int)(g_src[g_pos] - '0');
        g_pos = g_pos + 1;
    }
    if (!any) return 0;
    *out_v = v * sign;
    return 1;
}

static int parse_expr(int *out_v);

static int parse_primary(int *out_v) {
    int v;
    skip_space();
    if (consume_char('(')) {
        if (!parse_expr(&v)) return 0;
        if (!consume_char(')')) return 0;
        *out_v = v;
        return 1;
    }
    return parse_int_lit(out_v);
}

static int parse_mul(int *out_v) {
    int lhs;
    int rhs;
    char op;

    if (!parse_primary(&lhs)) return 0;
    for (;;) {
        skip_space();
        op = g_src[g_pos];
        if (op != '*' && op != '/') break;
        g_pos = g_pos + 1;
        if (!parse_primary(&rhs)) return 0;
        if (op == '*') {
            lhs = lhs * rhs;
        } else {
            if (rhs == 0) return 0;
            lhs = lhs / rhs;
        }
    }
    *out_v = lhs;
    return 1;
}

static int parse_expr(int *out_v) {
    int lhs;
    int rhs;
    char op;

    if (!parse_mul(&lhs)) return 0;
    for (;;) {
        skip_space();
        op = g_src[g_pos];
        if (op != '+' && op != '-') break;
        g_pos = g_pos + 1;
        if (!parse_mul(&rhs)) return 0;
        if (op == '+') {
            lhs = lhs + rhs;
        } else {
            lhs = lhs - rhs;
        }
    }
    *out_v = lhs;
    return 1;
}

static int parse_program_return_value(int *out_ret) {
    int v;
    if (!consume_kw("int")) return 0;
    if (!consume_kw("main")) return 0;
    if (!consume_char('(')) return 0;
    if (!consume_char(')')) {
        if (!consume_kw("void")) return 0;
        if (!consume_char(')')) return 0;
    }
    if (!consume_char('{')) return 0;

    if (consume_kw("int")) {
        /* Tiny local-int form: int x; x = <expr>; return x; */
        if (!consume_kw("x")) return 0;
        if (!consume_char(';')) return 0;
        if (!consume_kw("x")) return 0;
        if (!consume_char('=')) return 0;
        if (!parse_expr(&v)) return 0;
        if (!consume_char(';')) return 0;
        if (!consume_kw("return")) return 0;
        if (!consume_kw("x")) return 0;
        if (!consume_char(';')) return 0;
        *out_ret = v;
    } else {
        if (!consume_kw("return")) return 0;
        if (!parse_expr(out_ret)) return 0;
        if (!consume_char(';')) return 0;
    }

    if (!consume_char('}')) return 0;
    skip_space();
    return g_src[g_pos] == 0;
}

static int emit_min_asm(const char *out_path, int ret_imm) {
    FILE *f = fopen(out_path, "wb");
    if (!f) return 0;
    if (fputs("# Generated by Stage 8 cc-min spike\n", f) < 0) { fclose(f); return 0; }
    if (fputs(".text\n", f) < 0) { fclose(f); return 0; }
    if (fputs("main:\n", f) < 0) { fclose(f); return 0; }
    if (fputs("    .global main\n", f) < 0) { fclose(f); return 0; }
    if (fputs("    addi r29, r29, -256\n", f) < 0) { fclose(f); return 0; }
    if (fputs("    stw r29, r31, 252\n", f) < 0) { fclose(f); return 0; }
    if (fputs("    stw r29, r30, 248\n", f) < 0) { fclose(f); return 0; }
    if (fputs("    addi r30, r29, 256\n", f) < 0) { fclose(f); return 0; }
    if (fprintf(f, "    addi r1, r0, %d\n", ret_imm) < 0) { fclose(f); return 0; }
    if (fputs("    jal r0, .L0\n", f) < 0) { fclose(f); return 0; }
    if (fputs(".L0:\n", f) < 0) { fclose(f); return 0; }
    if (fputs("    ldw r31, r29, 252\n", f) < 0) { fclose(f); return 0; }
    if (fputs("    ldw r30, r29, 248\n", f) < 0) { fclose(f); return 0; }
    if (fputs("    addi r29, r29, 256\n", f) < 0) { fclose(f); return 0; }
    if (fputs("    jalr r0, r31, 0\n", f) < 0) { fclose(f); return 0; }
    if (fclose(f) != 0) return 0;
    return 1;
}

int main(int argc, char **argv) {
    uint32_t src_len;
    int ret_imm;
    if (argc != 3) {
        fprintf(stderr, "usage: %s <input.c> <output.s>\n", argv[0]);
        return 1;
    }
    if (!read_file(argv[1], g_src, MAX_SRC, &src_len)) {
        fprintf(stderr, "error: unable to read %s\n", argv[1]);
        return 1;
    }
    (void)src_len;
    g_pos = 0;
    if (!parse_program_return_value(&ret_imm)) {
        fprintf(stderr, "error: unsupported source shape\n");
        return 1;
    }
    if (ret_imm < -2048 || ret_imm > 2047) {
        fprintf(stderr, "error: return immediate out of range\n");
        return 1;
    }
    if (!emit_min_asm(argv[2], ret_imm)) {
        fprintf(stderr, "error: unable to write %s\n", argv[2]);
        return 1;
    }
    return 0;
}
